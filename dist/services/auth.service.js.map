{"version":3,"sources":["../../src/services/auth.service.ts"],"sourcesContent":["import { hash, compare } from 'bcrypt';\nimport { sign } from 'jsonwebtoken';\nimport { Service } from 'typedi';\nimport { SECRET_KEY } from '@config';\nimport pg from '@database';\nimport { HttpException } from '@exceptions/httpException';\nimport { DataStoredInToken, TokenData } from '@interfaces/auth.interface';\nimport { Customer, CustomerLogin } from '@interfaces/customers.interface';\nimport { Merchant } from '@interfaces/merchant.interface';\nimport { RedisClient } from '@/database/redis';\nimport moment from 'moment';\nimport bcrypt from 'bcrypt';\nimport { CustomError } from '@exceptions/CustomError';\n\nconst createToken = (customer: Customer): TokenData => {\n  const dataStoredInToken: DataStoredInToken = { id: customer.id };\n  const expiresIn: number = 60 * 60;\n\n  return { expiresIn, token: sign(dataStoredInToken, SECRET_KEY, { expiresIn }) };\n};\nconst createTokenMerchant = (merchant: Merchant): TokenData => {\n  const dataStoredInToken: DataStoredInToken = { id: merchant.id, role: 'Merchant' };\n  const expiresIn: number = 60 * 60;\n\n  return { expiresIn, token: sign(dataStoredInToken, SECRET_KEY, { expiresIn }) };\n};\nconst createCookie = (tokenData: TokenData): string => {\n  return `Authorization=${tokenData.token}; HttpOnly; Max-Age=${tokenData.expiresIn};`;\n};\n\n@Service()\nexport class AuthService {\n  private redis: RedisClient;\n  constructor() {\n    this.redis = new RedisClient();\n  }\n  public async signup(customerData: Customer, trust: boolean, uid?: string): Promise<{ customer: Customer; cookie: string; token: string }> {\n    const { name, phone, password } = customerData;\n    const { rows: findCustomer } = await pg.query(\n      `\n        SELECT EXISTS(\n                 SELECT \"phone\"\n                 FROM customer\n                 WHERE \"phone\" = $1\n                 )`,\n      [phone],\n    );\n    if (findCustomer[0].exists) throw new CustomError('NUMBER_TAKEN');\n\n    const hashedPassword = await hash(password, 10);\n    const { rows: signUpCustomerData } = await pg.query(\n      `\n        INSERT INTO customer(\"name\",\n                             \"phone\",\n                             \"hashed_password\")\n        VALUES ($1, $2, $3)\n        RETURNING \"id\",phone,hashed_password\n      `,\n      [name, phone, hashedPassword],\n    );\n    if (uid && trust) {\n      console.log(uid);\n      pg.query(\n        `INSERT INTO customer_device(customer_id, device_id)\n         values ($1, $2)`,\n        [signUpCustomerData[0].id, uid],\n      );\n    }\n    const tokenData = createToken(signUpCustomerData[0]);\n    const token = tokenData.token;\n    const cookie = createCookie(tokenData);\n    return { customer: signUpCustomerData[0], cookie, token };\n  }\n\n  public async login(CustomerData: CustomerLogin, deviceId: any): Promise<{ tokenData: TokenData; findCustomer: any }> {\n    let customerStatus: { is_blocked?: boolean; last_login_attempt?: moment.Moment | null; safe_login_after?: number | null } = {};\n\n    const { phone, password, trust, otp } = CustomerData;\n    const newTrust = trust || false;\n\n    const { rows, rowCount } = await pg.query(\n      `\n        SELECT \"id\",\n               \"phone\",\n               \"hashed_password\"\n        FROM customer\n        WHERE \"phone\" = $1\n      `,\n      [phone],\n    );\n\n    if (!rowCount) {\n      throw new CustomError('USER_NOT_FOUND');\n    }\n\n    const customerStatusResult = await this.redis.hGet('customer_status', phone);\n\n    if (customerStatusResult) {\n      customerStatus = JSON.parse(customerStatusResult);\n\n      if (customerStatus.is_blocked) {\n        const unBlockTime = moment(customerStatus.last_login_attempt).add(1, 'minute');\n\n        if (moment().isBefore(unBlockTime)) {\n          const timeLeft = unBlockTime.diff(moment(), 'seconds');\n          console.log(timeLeft);\n          throw new CustomError('USER_BLOCKED', null, timeLeft);\n        }\n\n        customerStatus.is_blocked = false;\n        customerStatus.last_login_attempt = null; // Set to null since it's not a Moment object anymore\n      }\n    }\n\n    const deviceResult = await pg.query(`Select * from customer_device where device_id= $1 and customer_id = $2`, [deviceId, rows[0].id]);\n\n    const loginType = deviceResult.rows.length > 0 ? 'otp' : 'password';\n\n    if (loginType === 'password') {\n      const isCorrect = bcrypt.compareSync(password, rows[0].hashed_password);\n\n      if (!isCorrect) {\n        if (\n          customerStatus.last_login_attempt &&\n          moment().isBefore(moment(customerStatus.last_login_attempt).add(customerStatus.safe_login_after, 'seconds'))\n        ) {\n          customerStatus.is_blocked = true;\n          customerStatus.safe_login_after = 0;\n        } else {\n          customerStatus.safe_login_after = customerStatus.last_login_attempt\n            ? Math.max(60 - moment().diff(customerStatus.last_login_attempt, 'seconds'), 0)\n            : 0;\n        }\n\n        customerStatus.last_login_attempt = moment();\n        await this.redis.hSet('customer_status', phone, JSON.stringify(customerStatus));\n\n        if (customerStatus.is_blocked) {\n          throw new CustomError('USER_BLOCKED');\n        } else {\n          throw new CustomError('WRONG_PASSWORD');\n        }\n      }\n    } else {\n      const redisOtp = await this.redis.hGet('otp', phone);\n\n      if (!redisOtp) {\n        return;\n      }\n\n      const otpObject = JSON.parse(redisOtp);\n\n      if (moment().isAfter(otpObject.expiresAt)) {\n        await this.redis.hDel('otp', phone);\n        throw new CustomError('EXPIRED_OTP');\n      }\n\n      if (otpObject.code === parseInt(otp) && moment().isBefore(otpObject.expiresAt)) {\n        await this.redis.hDel('otp', phone);\n      } else {\n        return;\n      }\n    }\n\n    if (newTrust) {\n      await pg.query(`Insert into customer_device(customer_id, device_id) values ($1,$2)`, [rows[0].id, deviceId]);\n    }\n\n    const tokenData: TokenData = createToken(rows[0]); // Replace with your token creation logic\n    return { tokenData, findCustomer: rows[0] };\n  }\n\n  public async getLoginType(phone: string, deviceId?: string) {\n    const { rows } = await pg.query(\n      `Select *\n                                     from customer\n                                     where phone = $1`,\n      [phone],\n    );\n    if (!rows[0]) throw new CustomError('USER_NOT_FOUND');\n    if (!deviceId) {\n      return { password: true, otp: false };\n    }\n\n    const { rows: customerPhone } = await pg.query(\n      `Select *\n                                                    from customer_device\n                                                    where customer_id = $1`,\n      [rows[0].id],\n    );\n    if (!customerPhone[0]) return { password: true, otp: false };\n    const otpObject = {\n      code: Math.floor(100000 + Math.random() * 900000),\n      expiresAt: moment().add(2, 'minutes').valueOf(),\n    };\n    this.redis.hSet('otp', rows[0].phone, JSON.stringify(otpObject));\n    return { password: false, otp: true };\n  }\n\n  public async logout(customerData: Customer): Promise<Customer> {\n    const { phone, hashed_password } = customerData;\n\n    const { rows, rowCount } = await pg.query(\n      `\n        SELECT \"phone\",\n               \"hashed_password\"\n        FROM customer\n        WHERE \"phone\" = $1\n          AND \"hashed_password\" = $2\n      `,\n      [phone, hashed_password],\n    );\n    if (!rowCount) throw new HttpException(409, \"Customer doesn't exist\");\n\n    return rows[0];\n  }\n\n  public async signUpMerchant(merchant: Merchant): Promise<{ tokenData: TokenData; cookie: string; merchant: any }> {\n    const { name, email, password } = merchant;\n    const { rows: findMerchant } = await pg.query(\n      `\n        SELECT EXISTS(\n                 SELECT \"email\"\n                 FROM merchant\n                 WHERE \"email\" = $1\n                 )`,\n      [email],\n    );\n    if (findMerchant[0].exists) throw new CustomError('EMAIL_TAKEN');\n\n    const hashedPassword = await hash(password, 10);\n    const { rows: signMerchantData } = await pg.query(\n      `\n        INSERT INTO merchant(\"name\",\n                             \"email\",\n                             \"hashed_password\")\n        VALUES ($1, $2, $3)\n        RETURNING \"id\",email,hashed_password\n      `,\n      [name, email, hashedPassword],\n    );\n    const tokenData = createTokenMerchant(signMerchantData[0]);\n    const cookie = createCookie(tokenData);\n    return { merchant: signMerchantData[0], tokenData, cookie };\n  }\n\n  public async loginMerchant(merchant: Merchant): Promise<{ cookie: string; tokenData: TokenData; merchant: any }> {\n    const { email, password } = merchant;\n    const { rows, rowCount } = await pg.query(\n      `\n        SELECT \"id\",\n               \"email\",\n               \"hashed_password\"\n        FROM merchant\n        WHERE \"email\" = $1\n      `,\n      [email],\n    );\n    if (!rowCount) throw new CustomError('USER_NOT_FOUND');\n\n    const isPasswordMatching: boolean = await compare(password, rows[0].hashed_password);\n    if (!isPasswordMatching) throw new CustomError('WRONG_PASSWORD');\n    const tokenData = createTokenMerchant(rows[0]);\n    const cookie = createCookie(tokenData);\n    return { merchant: rows[0], cookie, tokenData };\n  }\n}\n"],"names":["AuthService","createToken","customer","dataStoredInToken","id","expiresIn","token","sign","SECRET_KEY","createTokenMerchant","merchant","role","createCookie","tokenData","signup","customerData","trust","uid","name","phone","password","rows","findCustomer","pg","query","exists","CustomError","hashedPassword","hash","signUpCustomerData","console","log","cookie","login","CustomerData","deviceId","customerStatus","otp","newTrust","rowCount","customerStatusResult","redis","hGet","JSON","parse","is_blocked","unBlockTime","moment","last_login_attempt","add","isBefore","timeLeft","diff","deviceResult","loginType","length","isCorrect","bcrypt","compareSync","hashed_password","safe_login_after","Math","max","hSet","stringify","redisOtp","otpObject","isAfter","expiresAt","hDel","code","parseInt","getLoginType","customerPhone","floor","random","valueOf","logout","HttpException","signUpMerchant","email","findMerchant","signMerchantData","loginMerchant","isPasswordMatching","compare","constructor","RedisClient","Service"],"mappings":"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"}