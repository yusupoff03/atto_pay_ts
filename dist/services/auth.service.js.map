{"version":3,"sources":["../../src/services/auth.service.ts"],"sourcesContent":["import { hash, compare } from 'bcrypt';\nimport { sign } from 'jsonwebtoken';\nimport { Service } from 'typedi';\nimport { SECRET_KEY } from '@config';\nimport pg from '@database';\nimport { HttpException } from '@exceptions/httpException';\nimport { DataStoredInToken, TokenData } from '@interfaces/auth.interface';\nimport { Customer, CustomerLogin } from '@interfaces/customers.interface';\nimport { Merchant } from '@interfaces/merchant.interface';\nimport { RedisClient } from '@/database/redis';\nimport moment from 'moment';\nimport bcrypt from 'bcrypt';\nimport { CustomError } from '@exceptions/CustomError';\nimport { MailSendingService } from '@services/mailSending.service';\nimport { sendVerification } from '@services/sms.service';\n\nexport const createToken = (customer: Customer): TokenData => {\n  const dataStoredInToken: DataStoredInToken = { id: customer.id };\n  const expiresIn = '1h';\n\n  return { expiresIn, token: sign(dataStoredInToken, SECRET_KEY, { expiresIn }) };\n};\nconst createTokenMerchant = (merchant: Merchant): TokenData => {\n  const dataStoredInToken: DataStoredInToken = { id: merchant.id, role: 'Merchant' };\n  const expiresIn = '1h';\n\n  return { expiresIn, token: sign(dataStoredInToken, SECRET_KEY, { expiresIn }) };\n};\n\n@Service()\nexport class AuthService {\n  private redis: RedisClient;\n\n  constructor() {\n    this.redis = new RedisClient();\n  }\n\n  public async signup(customerData: Customer, info: string, trust: boolean, deviceId, uid?: string): Promise<{ customer: Customer; token: string }> {\n    const { name, phone, password, otp } = customerData;\n    const { rows: findCustomer } = await pg.query(\n      `\n        SELECT EXISTS(\n                 SELECT \"phone\"\n                 FROM customer\n                 WHERE \"phone\" = $1\n                 )`,\n      [phone],\n    );\n    if (findCustomer[0].exists) throw new CustomError('NUMBER_TAKEN');\n    const details = await this.redis.hGet('customer_otp', JSON.stringify({ phone: phone, deviceId }));\n    const detailsObject = JSON.parse(details || '{}');\n    const expired = moment().isAfter(moment(detailsObject.expiresAt));\n    const tooManyTries = detailsObject.numAttempt >= 3;\n    const sameCode = detailsObject.code === parseInt(otp);\n    if (expired) throw new CustomError('EXPIRED_OTP');\n    if (tooManyTries) throw new CustomError('TOO_MANY_TRIES');\n    if (!sameCode) {\n      detailsObject.numAttempt++;\n      await this.redis.hSet('customer_otp', JSON.stringify({ phone: phone, deviceId }), JSON.stringify(detailsObject));\n      throw new CustomError('WRONG_OTP');\n    }\n    const hashedPassword = await hash(password, 10);\n    const { rows: signUpCustomerData } = await pg.query(\n      `\n        INSERT INTO customer(\"name\",\n                             \"phone\",\n                             \"hashed_password\")\n        VALUES ($1, $2, $3)\n        RETURNING \"id\",phone,hashed_password\n      `,\n      [name, phone, hashedPassword],\n    );\n    if (uid && trust) {\n      await pg.query(\n        `INSERT INTO customer_device(customer_id, device_id, name)\n         values ($1, $2, $3)`,\n        [signUpCustomerData[0].id, uid, info],\n      );\n    }\n    const tokenData = createToken(signUpCustomerData[0]);\n    const token = tokenData.token;\n    return { customer: signUpCustomerData[0], token };\n  }\n\n  public async login(CustomerData: CustomerLogin, deviceId: any, deviceInfo: string): Promise<{ tokenData: TokenData; findCustomer: any }> {\n    let customerStatus: { is_blocked?: boolean; last_login_attempt?: moment.Moment | null; safe_login_after?: number | null } = {};\n    const { phone, password, trust, otp } = CustomerData;\n    const getOptObject = JSON.stringify({\n      phone,\n      deviceId,\n    });\n    const newTrust = trust || false;\n\n    const { rows, rowCount } = await pg.query(\n      `\n        SELECT \"id\",\n               \"phone\",\n               \"hashed_password\"\n        FROM customer\n        WHERE \"phone\" = $1\n      `,\n      [phone],\n    );\n\n    if (!rowCount) {\n      throw new CustomError('USER_NOT_FOUND');\n    }\n    const status_object = JSON.stringify({ phone, deviceId });\n    const customerStatusResult = await this.redis.hGet('customer_status', status_object);\n\n    if (customerStatusResult) {\n      customerStatus = JSON.parse(customerStatusResult);\n\n      if (customerStatus.is_blocked) {\n        const unBlockTime = moment(customerStatus.last_login_attempt).add(1, 'minute');\n\n        if (moment().isBefore(unBlockTime)) {\n          const timeLeft = unBlockTime.diff(moment(), 'seconds');\n          throw new CustomError('USER_BLOCKED', null, timeLeft);\n        }\n\n        customerStatus.is_blocked = false;\n        customerStatus.last_login_attempt = null; // Set to null since it's not a Moment object anymore\n      }\n    }\n\n    const deviceResult = await pg.query(\n      `Select *\n from customer_device\n where device_id = $1\n   and customer_id = $2`,\n      [deviceId, rows[0].id],\n    );\n\n    const loginType = deviceResult.rows.length > 0 ? 'otp' : 'password';\n\n    if (loginType === 'password') {\n      const isCorrect = bcrypt.compareSync(password, rows[0].hashed_password);\n\n      if (!isCorrect) {\n        if (\n          customerStatus.last_login_attempt &&\n          moment().isBefore(moment(customerStatus.last_login_attempt).add(customerStatus.safe_login_after, 'seconds'))\n        ) {\n          customerStatus.is_blocked = true;\n          customerStatus.safe_login_after = 0;\n        } else {\n          customerStatus.safe_login_after = customerStatus.last_login_attempt\n            ? Math.max(60 - moment().diff(customerStatus.last_login_attempt, 'seconds'), 0)\n            : 0;\n        }\n        customerStatus.last_login_attempt = moment();\n        const status_object = JSON.stringify({ phone, deviceId });\n        await this.redis.hSet('customer_status', status_object, JSON.stringify(customerStatus));\n        if (customerStatus.is_blocked) {\n          throw new CustomError('USER_BLOCKED');\n        } else {\n          throw new CustomError('WRONG_PASSWORD');\n        }\n      }\n    } else {\n      const redisOtp = await this.redis.hGet('otp', getOptObject);\n      const otpObject = JSON.parse(redisOtp);\n      if (!redisOtp) {\n        throw new CustomError('WRONG_OTP');\n      }\n      if (otpObject.tries >= 3) {\n        throw new CustomError('TOO_MANY_TRIES');\n      }\n      if (otpObject.code !== parseInt(otp)) {\n        otpObject.tries += 1;\n        await this.redis.hSet('otp', getOptObject, JSON.stringify(otpObject));\n        await sendVerification(phone, otpObject.code);\n        throw new CustomError('WRONG_OTP');\n      }\n      if (moment().isAfter(otpObject.expiresAt)) {\n        await this.redis.hDel('otp', getOptObject);\n        throw new CustomError('EXPIRED_OTP');\n      }\n      if (otpObject.code === parseInt(otp) && moment().isBefore(otpObject.expiresAt) && otpObject.tries < 3) {\n        await this.redis.hDel('otp', getOptObject);\n      } else {\n        return;\n      }\n    }\n\n    if (newTrust) {\n      await pg.query(\n        `Insert into customer_device(customer_id, device_id, name)\n                      values ($1, $2, $3)`,\n        [rows[0].id, deviceId, deviceInfo],\n      );\n    }\n\n    const tokenData: TokenData = createToken(rows[0]);\n    return { tokenData, findCustomer: rows[0] };\n  }\n\n  public async getLoginType(phone: string, deviceId: string) {\n    const { rows } = await pg.query(\n      `Select *\n       from customer\n       where phone = $1`,\n      [phone],\n    );\n    if (!rows[0]) throw new CustomError('USER_NOT_FOUND');\n    const otpObject = {\n      code: Math.floor(100000 + Math.random() * 900000),\n      expiresAt: moment().add(2, 'minutes').valueOf(),\n      tries: 0,\n    };\n    const { rows: customerPhone } = await pg.query(\n      `Select *\n       from customer_device\n       where customer_id = $1 and device_id = $2`,\n      [rows[0].id, deviceId],\n    );\n    if (!customerPhone[0]) return { password: true, otp: false };\n    const redisObject = {\n      phone,\n      deviceId,\n    };\n    const redisOtp = JSON.parse(await this.redis.hGet('otp', JSON.stringify(redisObject)));\n    if (!redisOtp || moment().isAfter(redisOtp.expiresAt)) {\n      if (redisOtp && moment().isAfter(redisOtp.expiresAt)) {\n        await this.redis.hDel('otp', JSON.stringify(redisObject));\n      }\n      await this.redis.hSet('otp', JSON.stringify(redisObject), JSON.stringify(otpObject));\n      await sendVerification(rows[0].phone, otpObject.code);\n      return { password: false, otp: true, timeLeft: moment(otpObject.expiresAt).diff(moment(), 'seconds') };\n    }\n    return { password: false, otp: true, timeLeft: moment(redisOtp.expiresAt).diff(moment(), 'seconds') };\n  }\n\n  public async logout(customerData: Customer): Promise<Customer> {\n    const { phone, hashed_password } = customerData;\n\n    const { rows, rowCount } = await pg.query(\n      `\n        SELECT \"phone\",\n               \"hashed_password\"\n        FROM customer\n        WHERE \"phone\" = $1\n          AND \"hashed_password\" = $2\n      `,\n      [phone, hashed_password],\n    );\n    if (!rowCount) throw new HttpException(409, \"Customer doesn't exist\");\n\n    return rows[0];\n  }\n\n  public async signUpMerchant(merchant: Merchant, email, code): Promise<{ tokenData: TokenData; merchant: any }> {\n    const { name, password } = merchant;\n    const { rows: findMerchant } = await pg.query(\n      `\n        SELECT EXISTS(\n                 SELECT \"email\"\n                 FROM merchant\n                 WHERE \"email\" = $1\n                 )`,\n      [email],\n    );\n    if (findMerchant[0].exists) throw new CustomError('EMAIL_TAKEN');\n    const redisCode = await this.redis.hGet('verification_code', email);\n    const codeObject = JSON.parse(redisCode);\n    if (!codeObject) throw new CustomError('WRONG_OTP');\n    if (moment().isAfter(codeObject.expiresAt)) {\n      await this.redis.hDel('verification_code', email);\n      throw new CustomError('EXPIRED_OTP');\n    }\n    if (codeObject.numAttempt == 3) {\n      throw new CustomError('TOO_MANY_TRIES');\n    }\n    if (codeObject.code === parseInt(code) && moment().isBefore(codeObject.expiresAt)) {\n      const hashedPassword = await hash(password, 10);\n      const { rows: signMerchantData } = await pg.query(\n        `\n          INSERT INTO merchant(\"name\",\n                               \"email\",\n                               \"hashed_password\")\n          VALUES ($1, $2, $3)\n          RETURNING \"id\",email,hashed_password\n        `,\n        [name, email, hashedPassword],\n      );\n      await this.redis.hDel('verification_code', email);\n      const tokenData = createTokenMerchant(signMerchantData[0]);\n      return { merchant: signMerchantData[0], tokenData };\n    }\n    codeObject.numAttempt += 1;\n    await this.redis.hSet('verification_code', email, JSON.stringify(codeObject));\n    throw new CustomError('WRONG_OTP');\n  }\n\n  public async sendCode(email, resend): Promise<any> {\n    const redisCode = await this.redis.hGet('verification_code', email);\n    const codeObject = JSON.parse(redisCode);\n    const codeObject1 = {\n      code: Math.floor(100000 + Math.random() * 900000),\n      expiresAt: moment().add(2, 'minutes').valueOf(),\n      numAttempt: 0,\n    };\n    if (!redisCode || moment().isAfter(codeObject.expiresAt)) {\n      await this.redis.hSet('verification_code', email, JSON.stringify(codeObject1));\n      await MailSendingService.mailSender(email, codeObject1.code);\n      return moment(codeObject1.expiresAt).diff(moment(), 'seconds');\n    }\n    if (redisCode && resend) {\n      if (moment().isAfter(codeObject.expiresAt)) {\n        await this.redis.hSet('verification_code', email, JSON.stringify(codeObject1));\n        await MailSendingService.mailSender(email, codeObject1.code);\n        return moment(codeObject1.expiresAt).diff(moment(), 'seconds');\n      }\n      const timeLeft = moment(codeObject.expiresAt).diff(moment(), 'seconds');\n      throw new CustomError('CODE_ALREADY_SEND', null, { timeLeft });\n    }\n  }\n\n  public async loginMerchant(email, password, deviceId): Promise<{ tokenData: TokenData; merchant: any }> {\n    let merchantStatus: { is_blocked: boolean; last_login_attempt: moment.Moment; safe_login_after: number } = {\n      is_blocked: false,\n      last_login_attempt: null,\n      safe_login_after: 0,\n    };\n    const { rows, rowCount } = await pg.query(\n      `\n        SELECT \"id\",\n               \"email\",\n               \"hashed_password\"\n        FROM merchant\n        WHERE \"email\" = $1\n      `,\n      [email],\n    );\n    if (!rowCount) throw new CustomError('USER_NOT_FOUND');\n    const status_object = `${email}_${deviceId}`;\n    const redis_status = await this.redis.hGet('merchant_status', status_object);\n    if (redis_status) {\n      merchantStatus = JSON.parse(redis_status);\n      if (merchantStatus.is_blocked) {\n        const unblockTime = moment(merchantStatus.last_login_attempt).add(1, 'minute');\n        if (moment().isBefore(unblockTime)) {\n          const timeLeft = unblockTime.diff(moment(), 'seconds');\n          throw new CustomError('USER_BLOCKED', null, timeLeft);\n        }\n        merchantStatus.is_blocked = false;\n        merchantStatus.last_login_attempt = null;\n      }\n    }\n    const isPasswordMatching: boolean = await compare(password, rows[0].hashed_password);\n    if (!isPasswordMatching) {\n      if (\n        merchantStatus.last_login_attempt &&\n        moment().isBefore(moment(merchantStatus.last_login_attempt).add(merchantStatus.safe_login_after, 'seconds'))\n      ) {\n        merchantStatus.is_blocked = true;\n        merchantStatus.safe_login_after = 0;\n      } else {\n        merchantStatus.safe_login_after = merchantStatus.last_login_attempt\n          ? Math.max(120 - moment().diff(merchantStatus.last_login_attempt, 'seconds'))\n          : 0;\n      }\n      merchantStatus.last_login_attempt = moment();\n      const statusObject = `${email}_${deviceId}`;\n      await this.redis.hSet('merchant_status', statusObject, JSON.stringify(merchantStatus));\n      if (merchantStatus.is_blocked) {\n        const unblockTime = moment(merchantStatus.last_login_attempt).add(1, 'minute');\n        const timeLeft = unblockTime.diff(moment(), 'seconds');\n        throw new CustomError('USER_BLOCKED', null, timeLeft);\n      } else {\n        throw new CustomError('WRONG_PASSWORD');\n      }\n    }\n    const statusObject = `${email}_${deviceId}`;\n    await this.redis.hDel('merchant_status', statusObject);\n    const tokenData = createTokenMerchant(rows[0]);\n    return { merchant: rows[0], tokenData };\n  }\n}\n"],"names":["createToken","AuthService","customer","dataStoredInToken","id","expiresIn","token","sign","SECRET_KEY","createTokenMerchant","merchant","role","signup","customerData","info","trust","deviceId","uid","name","phone","password","otp","rows","findCustomer","pg","query","exists","CustomError","details","redis","hGet","JSON","stringify","detailsObject","parse","expired","moment","isAfter","expiresAt","tooManyTries","numAttempt","sameCode","code","parseInt","hSet","hashedPassword","hash","signUpCustomerData","tokenData","login","CustomerData","deviceInfo","customerStatus","getOptObject","newTrust","rowCount","status_object","customerStatusResult","is_blocked","unBlockTime","last_login_attempt","add","isBefore","timeLeft","diff","deviceResult","loginType","length","isCorrect","bcrypt","compareSync","hashed_password","safe_login_after","Math","max","redisOtp","otpObject","tries","sendVerification","hDel","getLoginType","floor","random","valueOf","customerPhone","redisObject","logout","HttpException","signUpMerchant","email","findMerchant","redisCode","codeObject","signMerchantData","sendCode","resend","codeObject1","MailSendingService","mailSender","loginMerchant","merchantStatus","redis_status","unblockTime","isPasswordMatching","compare","statusObject","constructor","RedisClient","Service"],"mappings":"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"}