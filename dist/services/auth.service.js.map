{"version":3,"sources":["../../src/services/auth.service.ts"],"sourcesContent":["import { hash, compare } from 'bcrypt';\nimport { sign } from 'jsonwebtoken';\nimport { Service } from 'typedi';\nimport { SECRET_KEY } from '@config';\nimport pg from '@database';\nimport { HttpException } from '@exceptions/httpException';\nimport { DataStoredInToken, TokenData } from '@interfaces/auth.interface';\nimport { Customer, CustomerLogin } from '@interfaces/customers.interface';\nimport { Merchant } from '@interfaces/merchant.interface';\nimport { RedisClient } from '@/database/redis';\nimport moment from 'moment';\nimport bcrypt from 'bcrypt';\nimport { CustomError } from '@exceptions/CustomError';\nimport { MailSendingService } from '@services/mailSending.service';\nimport { CustomerService } from '@services/customers.service';\nimport { sendVerification } from '@services/sms.service';\n\nexport const createToken = (customer: Customer): TokenData => {\n  const dataStoredInToken: DataStoredInToken = { id: customer.id };\n  const expiresIn = '1h';\n\n  return { expiresIn, token: sign(dataStoredInToken, SECRET_KEY, { expiresIn }) };\n};\nconst createTokenMerchant = (merchant: Merchant): TokenData => {\n  const dataStoredInToken: DataStoredInToken = { id: merchant.id, role: 'Merchant' };\n  const expiresIn = '1h';\n\n  return { expiresIn, token: sign(dataStoredInToken, SECRET_KEY, { expiresIn }) };\n};\n\n@Service()\nexport class AuthService {\n  private redis: RedisClient;\n\n  constructor() {\n    this.redis = new RedisClient();\n  }\n\n  public async signup(customerData: Customer, info: string, trust: boolean, deviceId, uid?: string): Promise<{ customer: Customer; token: string }> {\n    const { name, phone, password, otp } = customerData;\n    const { rows: findCustomer } = await pg.query(\n      `\n        SELECT EXISTS(\n                 SELECT \"phone\"\n                 FROM customer\n                 WHERE \"phone\" = $1\n                 )`,\n      [phone],\n    );\n    if (findCustomer[0].exists) throw new CustomError('NUMBER_TAKEN');\n    const details = await this.redis.hGet('customer_otp', JSON.stringify({ phone: phone, deviceId }));\n    const detailsObject = JSON.parse(details || '{}');\n    const expired = moment().isAfter(moment(detailsObject.expiresAt));\n    const tooManyTries = detailsObject.numAttempt >= 3;\n    const sameCode = detailsObject.code === parseInt(otp);\n    if (expired) throw new CustomError('EXPIRED_OTP');\n    if (tooManyTries) throw new CustomError('TOO_MANY_TRIES');\n    if (!sameCode) {\n      detailsObject.numAttempt++;\n      await this.redis.hSet('customer_otp', JSON.stringify({ phone: phone, deviceId }), JSON.stringify(detailsObject));\n      throw new CustomError('WRONG_OTP');\n    }\n    const hashedPassword = await hash(password, 10);\n    const { rows: signUpCustomerData } = await pg.query(\n      `\n        INSERT INTO customer(\"name\",\n                             \"phone\",\n                             \"hashed_password\")\n        VALUES ($1, $2, $3)\n        RETURNING \"id\",phone,hashed_password\n      `,\n      [name, phone, hashedPassword],\n    );\n    if (uid && trust) {\n      await pg.query(\n        `INSERT INTO customer_device(customer_id, device_id, name)\n         values ($1, $2, $3)`,\n        [signUpCustomerData[0].id, uid, info],\n      );\n    }\n    const tokenData = createToken(signUpCustomerData[0]);\n    const token = tokenData.token;\n    return { customer: signUpCustomerData[0], token };\n  }\n\n  public async login(CustomerData: CustomerLogin, deviceId: any, deviceInfo: string): Promise<{ tokenData: TokenData; findCustomer: any }> {\n    let customerStatus: { is_blocked?: boolean; last_login_attempt?: moment.Moment | null; safe_login_after?: number | null } = {};\n    const { phone, password, trust, otp } = CustomerData;\n    const getOptObject = JSON.stringify({\n      phone,\n      deviceId,\n    });\n    const newTrust = trust || false;\n\n    const { rows, rowCount } = await pg.query(\n      `\n        SELECT \"id\",\n               \"phone\",\n               \"hashed_password\"\n        FROM customer\n        WHERE \"phone\" = $1\n      `,\n      [phone],\n    );\n\n    if (!rowCount) {\n      throw new CustomError('USER_NOT_FOUND');\n    }\n    const status_object = JSON.stringify({ phone, deviceId });\n    const customerStatusResult = await this.redis.hGet('customer_status', status_object);\n\n    if (customerStatusResult) {\n      customerStatus = JSON.parse(customerStatusResult);\n\n      if (customerStatus.is_blocked) {\n        const unBlockTime = moment(customerStatus.last_login_attempt).add(1, 'minute');\n\n        if (moment().isBefore(unBlockTime)) {\n          const timeLeft = unBlockTime.diff(moment(), 'seconds');\n          throw new CustomError('USER_BLOCKED', null, timeLeft);\n        }\n\n        customerStatus.is_blocked = false;\n        customerStatus.last_login_attempt = null; // Set to null since it's not a Moment object anymore\n      }\n    }\n\n    const deviceResult = await pg.query(\n      `Select *\n from customer_device\n where device_id = $1\n   and customer_id = $2`,\n      [deviceId, rows[0].id],\n    );\n\n    const loginType = deviceResult.rows.length > 0 ? 'otp' : 'password';\n\n    if (loginType === 'password') {\n      const isCorrect = bcrypt.compareSync(password, rows[0].hashed_password);\n\n      if (!isCorrect) {\n        if (\n          customerStatus.last_login_attempt &&\n          moment().isBefore(moment(customerStatus.last_login_attempt).add(customerStatus.safe_login_after, 'seconds'))\n        ) {\n          customerStatus.is_blocked = true;\n          customerStatus.safe_login_after = 0;\n        } else {\n          customerStatus.safe_login_after = customerStatus.last_login_attempt\n            ? Math.max(60 - moment().diff(customerStatus.last_login_attempt, 'seconds'), 0)\n            : 0;\n        }\n        customerStatus.last_login_attempt = moment();\n        const status_object = JSON.stringify({ phone, deviceId });\n        await this.redis.hSet('customer_status', status_object, JSON.stringify(customerStatus));\n        if (customerStatus.is_blocked) {\n          throw new CustomError('USER_BLOCKED');\n        } else {\n          throw new CustomError('WRONG_PASSWORD');\n        }\n      }\n    } else {\n      const redisOtp = await this.redis.hGet('otp', getOptObject);\n      const otpObject = JSON.parse(redisOtp);\n      if (!redisOtp) {\n        throw new CustomError('WRONG_OTP');\n      }\n      if (otpObject.tries >= 3) {\n        throw new CustomError('TOO_MANY_TRIES');\n      }\n      if (otpObject.code !== parseInt(otp)) {\n        otpObject.tries += 1;\n        await this.redis.hSet('otp', getOptObject, JSON.stringify(otpObject));\n        throw new CustomError('WRONG_OTP');\n      }\n      if (moment().isAfter(otpObject.expiresAt)) {\n        await this.redis.hDel('otp', getOptObject);\n        throw new CustomError('EXPIRED_OTP');\n      }\n      if (otpObject.code === parseInt(otp) && moment().isBefore(otpObject.expiresAt) && otpObject.tries < 3) {\n        await this.redis.hDel('otp', getOptObject);\n      } else {\n        return;\n      }\n    }\n\n    if (newTrust) {\n      await pg.query(\n        `Insert into customer_device(customer_id, device_id, name)\n                      values ($1, $2, $3)`,\n        [rows[0].id, deviceId, deviceInfo],\n      );\n    }\n\n    const tokenData: TokenData = createToken(rows[0]);\n    return { tokenData, findCustomer: rows[0] };\n  }\n\n  public async getLoginType(phone: string, deviceId: string) {\n    const { rows } = await pg.query(\n      `Select *\n       from customer\n       where phone = $1`,\n      [phone],\n    );\n    if (!rows[0]) throw new CustomError('USER_NOT_FOUND');\n    const otpObject = {\n      code: Math.floor(100000 + Math.random() * 900000),\n      expiresAt: moment().add(2, 'minutes').valueOf(),\n      tries: 0,\n    };\n    const { rows: customerPhone } = await pg.query(\n      `Select *\n       from customer_device\n       where customer_id = $1 and device_id = $2`,\n      [rows[0].id, deviceId],\n    );\n    if (!customerPhone[0]) return { password: true, otp: false };\n    const redisObject = {\n      phone,\n      deviceId,\n    };\n    const redisOtp = JSON.parse(await this.redis.hGet('otp', JSON.stringify(redisObject)));\n    if (!redisOtp || moment().isAfter(redisOtp.expiresAt)) {\n      await this.redis.hSet('otp', JSON.stringify(redisObject), JSON.stringify(otpObject));\n      // await sendVerification(rows[0].phone, otpObject.code);\n      return { password: false, otp: true, timeLeft: moment(otpObject.expiresAt).diff(moment(), 'seconds') };\n    }\n    return { password: false, otp: true, timeLeft: moment(redisOtp.expiresAt).diff(moment(), 'seconds') };\n  }\n\n  public async logout(customerData: Customer): Promise<Customer> {\n    const { phone, hashed_password } = customerData;\n\n    const { rows, rowCount } = await pg.query(\n      `\n        SELECT \"phone\",\n               \"hashed_password\"\n        FROM customer\n        WHERE \"phone\" = $1\n          AND \"hashed_password\" = $2\n      `,\n      [phone, hashed_password],\n    );\n    if (!rowCount) throw new HttpException(409, \"Customer doesn't exist\");\n\n    return rows[0];\n  }\n\n  public async signUpMerchant(merchant: Merchant, email, code): Promise<{ tokenData: TokenData; merchant: any }> {\n    const { name, password } = merchant;\n    const { rows: findMerchant } = await pg.query(\n      `\n        SELECT EXISTS(\n                 SELECT \"email\"\n                 FROM merchant\n                 WHERE \"email\" = $1\n                 )`,\n      [email],\n    );\n    if (findMerchant[0].exists) throw new CustomError('EMAIL_TAKEN');\n    const redisCode = await this.redis.hGet('verification_code', email);\n    const codeObject = JSON.parse(redisCode);\n    if (!codeObject) throw new CustomError('WRONG_OTP');\n    if (moment().isAfter(codeObject.expiresAt)) {\n      await this.redis.hDel('verification_code', email);\n      throw new CustomError('EXPIRED_OTP');\n    }\n    if (codeObject.numAttempt == 3) {\n      throw new CustomError('TOO_MANY_TRIES');\n    }\n    if (codeObject.code === parseInt(code) && moment().isBefore(codeObject.expiresAt)) {\n      const hashedPassword = await hash(password, 10);\n      const { rows: signMerchantData } = await pg.query(\n        `\n          INSERT INTO merchant(\"name\",\n                               \"email\",\n                               \"hashed_password\")\n          VALUES ($1, $2, $3)\n          RETURNING \"id\",email,hashed_password\n        `,\n        [name, email, hashedPassword],\n      );\n      await this.redis.hDel('verification_code', email);\n      const tokenData = createTokenMerchant(signMerchantData[0]);\n      return { merchant: signMerchantData[0], tokenData };\n    }\n    codeObject.numAttempt += 1;\n    await this.redis.hSet('verification_code', email, JSON.stringify(codeObject));\n    throw new CustomError('WRONG_OTP');\n  }\n\n  public async sendCode(email, resend): Promise<any> {\n    const redisCode = await this.redis.hGet('verification_code', email);\n    const codeObject = JSON.parse(redisCode);\n    const codeObject1 = {\n      code: Math.floor(100000 + Math.random() * 900000),\n      expiresAt: moment().add(2, 'minutes').valueOf(),\n      numAttempt: 0,\n    };\n    if (!redisCode || moment().isAfter(codeObject.expiresAt)) {\n      await this.redis.hSet('verification_code', email, JSON.stringify(codeObject1));\n      await MailSendingService.mailSender(email, codeObject1.code);\n      return moment(codeObject1.expiresAt).diff(moment(), 'seconds');\n    }\n    if (redisCode && resend) {\n      if (moment().isAfter(codeObject.expiresAt)) {\n        await this.redis.hSet('verification_code', email, JSON.stringify(codeObject1));\n        await MailSendingService.mailSender(email, codeObject1.code);\n        return moment(codeObject1.expiresAt).diff(moment(), 'seconds');\n      }\n      const timeLeft = moment(codeObject.expiresAt).diff(moment(), 'seconds');\n      throw new CustomError('CODE_ALREADY_SEND', null, { timeLeft });\n    }\n  }\n\n  public async loginMerchant(email, password, deviceId): Promise<{ tokenData: TokenData; merchant: any }> {\n    let merchantStatus: { is_blocked: boolean; last_login_attempt: moment.Moment; safe_login_after: number } = {\n      is_blocked: false,\n      last_login_attempt: null,\n      safe_login_after: 0,\n    };\n    const { rows, rowCount } = await pg.query(\n      `\n        SELECT \"id\",\n               \"email\",\n               \"hashed_password\"\n        FROM merchant\n        WHERE \"email\" = $1\n      `,\n      [email],\n    );\n    if (!rowCount) throw new CustomError('USER_NOT_FOUND');\n    const status_object = `${email}_${deviceId}`;\n    const redis_status = await this.redis.hGet('merchant_status', status_object);\n    if (redis_status) {\n      merchantStatus = JSON.parse(redis_status);\n      if (merchantStatus.is_blocked) {\n        const unblockTime = moment(merchantStatus.last_login_attempt).add(1, 'minute');\n        if (moment().isBefore(unblockTime)) {\n          const timeLeft = unblockTime.diff(moment(), 'seconds');\n          throw new CustomError('USER_BLOCKED', null, timeLeft);\n        }\n        merchantStatus.is_blocked = false;\n        merchantStatus.last_login_attempt = null;\n      }\n    }\n    const isPasswordMatching: boolean = await compare(password, rows[0].hashed_password);\n    if (!isPasswordMatching) {\n      if (\n        merchantStatus.last_login_attempt &&\n        moment().isBefore(moment(merchantStatus.last_login_attempt).add(merchantStatus.safe_login_after, 'seconds'))\n      ) {\n        merchantStatus.is_blocked = true;\n        merchantStatus.safe_login_after = 0;\n      } else {\n        merchantStatus.safe_login_after = merchantStatus.last_login_attempt\n          ? Math.max(120 - moment().diff(merchantStatus.last_login_attempt, 'seconds'))\n          : 0;\n      }\n      merchantStatus.last_login_attempt = moment();\n      const statusObject = `${email}_${deviceId}`;\n      await this.redis.hSet('merchant_status', statusObject, JSON.stringify(merchantStatus));\n      if (merchantStatus.is_blocked) {\n        const unblockTime = moment(merchantStatus.last_login_attempt).add(1, 'minute');\n        const timeLeft = unblockTime.diff(moment(), 'seconds');\n        throw new CustomError('USER_BLOCKED', null, timeLeft);\n      } else {\n        throw new CustomError('WRONG_PASSWORD');\n      }\n    }\n    const statusObject = `${email}_${deviceId}`;\n    await this.redis.hDel('merchant_status', statusObject);\n    const tokenData = createTokenMerchant(rows[0]);\n    return { merchant: rows[0], tokenData };\n  }\n}\n"],"names":["createToken","AuthService","customer","dataStoredInToken","id","expiresIn","token","sign","SECRET_KEY","createTokenMerchant","merchant","role","signup","customerData","info","trust","deviceId","uid","name","phone","password","otp","rows","findCustomer","pg","query","exists","CustomError","details","redis","hGet","JSON","stringify","detailsObject","parse","expired","moment","isAfter","expiresAt","tooManyTries","numAttempt","sameCode","code","parseInt","hSet","hashedPassword","hash","signUpCustomerData","tokenData","login","CustomerData","deviceInfo","customerStatus","getOptObject","newTrust","rowCount","status_object","customerStatusResult","is_blocked","unBlockTime","last_login_attempt","add","isBefore","timeLeft","diff","deviceResult","loginType","length","isCorrect","bcrypt","compareSync","hashed_password","safe_login_after","Math","max","redisOtp","otpObject","tries","hDel","getLoginType","floor","random","valueOf","customerPhone","redisObject","logout","HttpException","signUpMerchant","email","findMerchant","redisCode","codeObject","signMerchantData","sendCode","resend","codeObject1","MailSendingService","mailSender","loginMerchant","merchantStatus","redis_status","unblockTime","isPasswordMatching","compare","statusObject","constructor","RedisClient","Service"],"mappings":"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"}